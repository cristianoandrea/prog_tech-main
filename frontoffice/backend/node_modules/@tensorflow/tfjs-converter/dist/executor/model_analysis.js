/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { parseNodeName } from '../operations/executors/utils';
/**
 * Given graph inputs and desired outputs, find the minimal set of nodes
 * to execute in order to compute the outputs. In addition return other useful
 * info such:
 * - Missing inputs needed to compute the output.
 * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).
 * - Alternative inputs in order to avoid async (dynamic op) execution.
 */
export function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
    const usedNodes = new Set();
    const missingInputs = [];
    let dynamicNode = null;
    let syncInputs = null;
    // Start with the outputs, going backwards and find all the nodes that are
    // needed to compute those outputs.
    const seen = new Set();
    const inputNodeNames = new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));
    initNodes = initNodes || [];
    const initNodeNames = new Set(initNodes.map((node) => parseNodeName(node.name)[0]));
    const frontier = [...outputs];
    while (frontier.length > 0) {
        const node = frontier.pop();
        if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {
            if (dynamicNode == null) {
                dynamicNode = node;
                syncInputs = dynamicNode.children.map(child => child.name)
                    .filter(name => usedNodes.has(name));
            }
        }
        usedNodes.add(node.name);
        // Weights are dead end since we already have their values.
        if (weightMap[node.name] != null) {
            continue;
        }
        // This node is a dead end since it's one of the user-provided inputs.
        if (inputNodeNames.has(node.name)) {
            continue;
        }
        // This node is a dead end since it doesn't have any inputs.
        if (initNodeNames.has(node.name)) {
            continue;
        }
        if (node.inputs.length === 0) {
            missingInputs.push(node.name);
            continue;
        }
        node.inputs.forEach(input => {
            // Don't add to the frontier if it is already there.
            if (seen.has(input.name)) {
                return;
            }
            seen.add(input.name);
            frontier.push(input);
        });
    }
    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
}
/**
 * Given the execution info, return a list of nodes in topological order that
 * need to be executed to compute the output.
 */
export function getNodesInTopologicalOrder(graph, executionInfo) {
    const { usedNodes, inputs } = executionInfo;
    const inputNodes = Object.keys(inputs)
        .map(name => parseNodeName(name)[0])
        .map(name => graph.nodes[name]);
    const initNodes = graph.initNodes || [];
    const isUsed = (node) => usedNodes.has(typeof node === 'string' ? node : node.name);
    function unique(nodes) {
        return [...new Map(nodes.map((node) => [node.name, node])).values()];
    }
    const predefinedNodes = unique([
        ...inputNodes,
        ...graph.weights,
        ...initNodes,
    ]).filter(isUsed);
    const allNodes = unique([
        ...predefinedNodes,
        ...Object.values(graph.nodes),
    ]).filter(isUsed);
    const nameToNode = new Map(allNodes.map((node) => [node.name, node]));
    const inCounts = {};
    for (const node of allNodes) {
        inCounts[node.name] = inCounts[node.name] || 0;
        for (const child of node.children) {
            // When the child is unused, set in counts to infinity so that it will
            // never be decreased to 0 and added to the execution list.
            if (!isUsed(child)) {
                inCounts[child.name] = Number.POSITIVE_INFINITY;
            }
            inCounts[child.name] = (inCounts[child.name] || 0) + 1;
        }
    }
    // Build execution order for all used nodes regardless whether they are
    // predefined or not.
    const frontier = Object.entries(inCounts)
        .filter(([, inCount]) => inCount === 0)
        .map(([name]) => name);
    const orderedNodeNames = [...frontier];
    while (frontier.length > 0) {
        const nodeName = frontier.pop();
        const node = nameToNode.get(nodeName);
        for (const child of node.children.filter(isUsed)) {
            if (--inCounts[child.name] === 0) {
                orderedNodeNames.push(child.name);
                frontier.push(child.name);
            }
        }
    }
    const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));
    const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);
    // TODO: Turn validation on/off with tf env flag.
    validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);
    return filteredOrderedNodes;
}
/**
 * This is a helper function of `getNodesInTopologicalOrder`.
 * Returns ordered nodes reachable by at least one predefined node.
 * This can help us filter out redundant nodes from the returned node list.
 * For example:
 * If we have four nodes with dependencies like this:
 *   a --> b --> c --> d
 * when node `c` is predefined (e.g. given as an input tensor), we can
 * skip node `a` and `b` since their outputs will never be used.
 *
 * @param orderedNodes Graph nodes in execution order.
 * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this
 *     list must have distinct names.
 */
function filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {
    const nameToNode = new Map(orderedNodes.map((node) => [node.name, node]));
    // TODO: Filter out more nodes when >=2 nodes are predefined in a path.
    const stack = predefinedNodes.map((node) => node.name);
    const predefinedReachableNodeNames = new Set(stack);
    // Perform a DFS starting from the set of all predefined nodes
    // to find the set of all nodes reachable from the predefined nodes.
    while (stack.length > 0) {
        const nodeName = stack.pop();
        const node = nameToNode.get(nodeName);
        for (const child of node.children) {
            if (!nameToNode.has(child.name) ||
                predefinedReachableNodeNames.has(child.name)) {
                continue;
            }
            predefinedReachableNodeNames.add(child.name);
            stack.push(child.name);
        }
    }
    // Filter out unreachable nodes and build the ordered node list.
    const filteredOrderedNodes = orderedNodes.filter((node) => predefinedReachableNodeNames.has(node.name));
    return filteredOrderedNodes;
}
class NodesExecutionOrderError extends Error {
    constructor(message) {
        super(`NodesExecutionOrderError: ${message}`);
    }
}
/**
 * This is a helper function of `getNodesInTopologicalOrder`.
 * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`
 * is a child of `b`. This function throws an error if validation fails.
 *
 * @param orderedNodes Graph nodes in execution order.
 * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this
 *     list must have distinct names.
 */
function validateNodesExecutionOrder(orderedNodes, predefinedNodes) {
    const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
    const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));
    const isPredefined = (node) => predefinedNodeNames.has(typeof node === 'string' ? node : node.name);
    const willBeExecutedNodeNames = new Set(orderedNodes.map((node) => node.name));
    const willBeExecuted = (node) => willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);
    for (const node of orderedNodes) {
        for (const child of node.children.filter(willBeExecuted)) {
            if (!nodeNameToOrder.has(child.name)) {
                throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);
            }
            if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {
                throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);
            }
        }
        if (!isPredefined(node)) {
            for (const input of node.inputs) {
                if (!nodeNameToOrder.has(input.name)) {
                    throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);
                }
                if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {
                    throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);
                }
            }
        }
    }
}
/**
 * Given the execution info, return a map from node name to the disposable
 * node name list after its execution.
 *
 * @returns A map from node name to disposable node names after its
 *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates
 *     all nodes which their intermediate tensors should be disposed after `x`
 *     being executed.
 */
export function getNodeLiveUntilMap(orderedNodes) {
    const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
    const INF_LIFE = Number.MAX_SAFE_INTEGER;
    // Make control flow nodes (and consequently their direct parents)
    // live forever since they're tricky to track correctly.
    const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);
    const getSelfLifeSpan = (node) => {
        const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];
        if (selfLife == null) {
            // If nodeToOrder does not contain the node, it is unused or
            // unreachable in graph.
            return -1;
        }
        return selfLife;
    };
    // `liveUntil[i]` points to the last node in the `orderedNodes` array that
    // may depend on tensors from node `i`. It indicates that all the
    // intermediate tensors from `orderedNodes[i]` should be disposed after
    // `orderedNodes[liveUntil[i]]` is executed.
    // A node lives long enough to pass on its tensors to its children.
    // It lives until at least `max(node's position, children's positions)`.
    const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {
        return node.children.map(getSelfLifeSpan)
            .reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);
    });
    // liveUntilMap:
    // - Key: Name of a node `x`
    // - Values: All nodes whose intermediate tensors should be disposed
    //           after `x` is executed.
    const liveUntilMap = new Map();
    for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {
        const liveUntilOrder = liveUntilOrders[nodeOrder];
        if (liveUntilOrder === INF_LIFE) {
            continue;
        }
        const node = orderedNodes[nodeOrder];
        const liveUntilNode = orderedNodes[liveUntilOrder];
        if (!liveUntilMap.has(liveUntilNode.name)) {
            liveUntilMap.set(liveUntilNode.name, []);
        }
        liveUntilMap.get(liveUntilNode.name).push(node.name);
    }
    return liveUntilMap;
}
const CONTROL_FLOW_OPS = new Set([
    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',
    'StatelessWhile', 'if', 'While'
]);
const DYNAMIC_SHAPE_OPS = new Set([
    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'
]);
const HASH_TABLE_OPS = new Set([
    'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',
    'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'
]);
export function isControlFlow(node) {
    return CONTROL_FLOW_OPS.has(node.op);
}
export function isDynamicShape(node) {
    return DYNAMIC_SHAPE_OPS.has(node.op);
}
export function isHashTable(node) {
    return HASH_TABLE_OPS.has(node.op);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxfYW5hbHlzaXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvbnZlcnRlci9zcmMvZXhlY3V0b3IvbW9kZWxfYW5hbHlzaXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBS0gsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBWTVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQ2hDLE1BQXNCLEVBQUUsT0FBZSxFQUFFLFNBQTBCLEVBQ25FLFNBQWtCO0lBQ3BCLE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7SUFDcEMsTUFBTSxhQUFhLEdBQWEsRUFBRSxDQUFDO0lBQ25DLElBQUksV0FBVyxHQUFTLElBQUksQ0FBQztJQUM3QixJQUFJLFVBQVUsR0FBYSxJQUFJLENBQUM7SUFFaEMsMEVBQTBFO0lBQzFFLG1DQUFtQztJQUNuQyxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO0lBQy9CLE1BQU0sY0FBYyxHQUNoQixJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV2RSxTQUFTLEdBQUcsU0FBUyxJQUFJLEVBQUUsQ0FBQztJQUM1QixNQUFNLGFBQWEsR0FDZixJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVsRSxNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7SUFDOUIsT0FBTyxR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QztBQUNILE1BQU0saUJBQWlCLEdBQUcsSUFBSSxHQUFHLENBQUM7SUFDaEMscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUsT0FBTztDQUM3RSxDQUFDLENBQUM7QUFDSCxNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUM3QixXQUFXLEVBQUUsYUFBYSxFQUFFLG1CQUFtQixFQUFFLHFCQUFxQjtJQUN0RSxpQkFBaUIsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxtQkFBbUI7Q0FDL0UsQ0FBQyxDQUFDO0FBRUgsTUFBTSxVQUFVLGFBQWEsQ0FBQyxJQUFVO0lBQ3RDLE9BQU8sZ0JBQWdCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN2QyxDQUFDO0FBRUQsTUFBTSxVQUFVLGNBQWMsQ0FBQyxJQUFVO0lBQ3ZDLE9BQU8saUJBQWlCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQsTUFBTSxVQUFVLFdBQVcsQ0FBQyxJQUFVO0lBQ3BDLE9BQU8sY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDckMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtOYW1lZFRlbnNvck1hcH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtOYW1lZFRlbnNvcnNNYXB9IGZyb20gJy4uL2RhdGEvdHlwZXMnO1xuaW1wb3J0IHtwYXJzZU5vZGVOYW1lfSBmcm9tICcuLi9vcGVyYXRpb25zL2V4ZWN1dG9ycy91dGlscyc7XG5pbXBvcnQge0dyYXBoLCBOb2RlfSBmcm9tICcuLi9vcGVyYXRpb25zL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25JbmZvIHtcbiAgaW5wdXRzOiBOYW1lZFRlbnNvck1hcDtcbiAgb3V0cHV0czogTm9kZVtdO1xuICB1c2VkTm9kZXM6IFNldDxzdHJpbmc+O1xuICBtaXNzaW5nSW5wdXRzOiBzdHJpbmdbXTtcbiAgZHluYW1pY05vZGU6IE5vZGU7XG4gIHN5bmNJbnB1dHM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEdpdmVuIGdyYXBoIGlucHV0cyBhbmQgZGVzaXJlZCBvdXRwdXRzLCBmaW5kIHRoZSBtaW5pbWFsIHNldCBvZiBub2Rlc1xuICogdG8gZXhlY3V0ZSBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBvdXRwdXRzLiBJbiBhZGRpdGlvbiByZXR1cm4gb3RoZXIgdXNlZnVsXG4gKiBpbmZvIHN1Y2g6XG4gKiAtIE1pc3NpbmcgaW5wdXRzIG5lZWRlZCB0byBjb21wdXRlIHRoZSBvdXRwdXQuXG4gKiAtIFdoZXRoZXIgdGhlIHN1YmdyYXBoIGNvbnRhaW5zIGR5bmFtaWMgb3BzIChjb250cm9sIGZsb3csIGR5bmFtaWMgc2hhcGUpLlxuICogLSBBbHRlcm5hdGl2ZSBpbnB1dHMgaW4gb3JkZXIgdG8gYXZvaWQgYXN5bmMgKGR5bmFtaWMgb3ApIGV4ZWN1dGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4ZWN1dGlvblN1YmdyYXBoKFxuICAgIGlucHV0czogTmFtZWRUZW5zb3JNYXAsIG91dHB1dHM6IE5vZGVbXSwgd2VpZ2h0TWFwOiBOYW1lZFRlbnNvcnNNYXAsXG4gICAgaW5pdE5vZGVzPzogTm9kZVtdKTogRXhlY3V0aW9uSW5mbyB7XG4gIGNvbnN0IHVzZWROb2RlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCBtaXNzaW5nSW5wdXRzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgZHluYW1pY05vZGU6IE5vZGUgPSBudWxsO1xuICBsZXQgc3luY0lucHV0czogc3RyaW5nW10gPSBudWxsO1xuXG4gIC8vIFN0YXJ0IHdpdGggdGhlIG91dHB1dHMsIGdvaW5nIGJhY2t3YXJkcyBhbmQgZmluZCBhbGwgdGhlIG5vZGVzIHRoYXQgYXJlXG4gIC8vIG5lZWRlZCB0byBjb21wdXRlIHRob3NlIG91dHB1dHMuXG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgaW5wdXROb2RlTmFtZXMgPVxuICAgICAgbmV3IFNldChPYmplY3Qua2V5cyhpbnB1dHMpLm1hcCgobmFtZSkgPT4gcGFyc2VOb2RlTmFtZShuYW1lKVswXSkpO1xuXG4gIGluaXROb2RlcyA9IGluaXROb2RlcyB8fCBbXTtcbiAgY29uc3QgaW5pdE5vZGVOYW1lcyA9XG4gICAgICBuZXcgU2V0KGluaXROb2Rlcy5tYXAoKG5vZGUpID0+IHBhcnNlTm9kZU5hbWUobm9kZS5uYW1lKVswXSkpO1xuXG4gIGNvbnN0IGZyb250aWVyID0gWy4uLm91dHB1dHNdO1xuICB3aGlsZSAoZnJvbnRpZXIubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5vZGUgPSBmcm9udGllci5wb3AoKTtcbiAgICBpZiAoaXNDb250cm9sRmxvdyhub2RlKSB8fCBpc0R5bmFtaWNTaGFwZShub2RlKSB8fCBpc0hhc2hUYWJsZShub2RlKSkge1xuICAgICAgaWYgKGR5bmFtaWNOb2RlID09IG51bGwpIHtcbiAgICAgICAgZHluYW1pY05vZGUgPSBub2RlO1xuICAgICAgICBzeW5jSW5wdXRzID0gZHluYW1pY05vZGUuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihuYW1lID0+IHVzZWROb2Rlcy5oYXMobmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB1c2VkTm9kZXMuYWRkKG5vZGUubmFtZSk7XG5cbiAgICAvLyBXZWlnaHRzIGFyZSBkZWFkIGVuZCBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgdGhlaXIgdmFsdWVzLlxuICAgIGlmICh3ZWlnaHRNYXBbbm9kZS5uYW1lXSAhPSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gVGhpcyBub2RlIGlzIGEgZGVhZCBlbmQgc2luY2UgaXQncyBvbmUgb2YgdGhlIHVzZXItcHJvdmlkZWQgaW5wdXRzLlxuICAgIGlmIChpbnB1dE5vZGVOYW1lcy5oYXMobm9kZS5uYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFRoaXMgbm9kZSBpcyBhIGRlYWQgZW5kIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgaW5wdXRzLlxuICAgIGlmIChpbml0Tm9kZU5hbWVzLmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbWlzc2luZ0lucHV0cy5wdXNoKG5vZGUubmFtZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbm9kZS5pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGZyb250aWVyIGlmIGl0IGlzIGFscmVhZHkgdGhlcmUuXG4gICAgICBpZiAoc2Vlbi5oYXMoaW5wdXQubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQoaW5wdXQubmFtZSk7XG4gICAgICBmcm9udGllci5wdXNoKGlucHV0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge2lucHV0cywgb3V0cHV0cywgdXNlZE5vZGVzLCBtaXNzaW5nSW5wdXRzLCBkeW5hbWljTm9kZSwgc3luY0lucHV0c307XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGV4ZWN1dGlvbiBpbmZvLCByZXR1cm4gYSBsaXN0IG9mIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyIHRoYXRcbiAqIG5lZWQgdG8gYmUgZXhlY3V0ZWQgdG8gY29tcHV0ZSB0aGUgb3V0cHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoXG4gICAgZ3JhcGg6IEdyYXBoLCBleGVjdXRpb25JbmZvOiBFeGVjdXRpb25JbmZvKTogTm9kZVtdIHtcbiAgY29uc3Qge3VzZWROb2RlcywgaW5wdXRzfSA9IGV4ZWN1dGlvbkluZm87XG4gIGNvbnN0IGlucHV0Tm9kZXMgPSBPYmplY3Qua2V5cyhpbnB1dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHBhcnNlTm9kZU5hbWUobmFtZSlbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IGdyYXBoLm5vZGVzW25hbWVdKTtcbiAgY29uc3QgaW5pdE5vZGVzID0gZ3JhcGguaW5pdE5vZGVzIHx8IFtdO1xuXG4gIGNvbnN0IGlzVXNlZCA9IChub2RlOiBOb2RlfHN0cmluZykgPT5cbiAgICAgIHVzZWROb2Rlcy5oYXModHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnID8gbm9kZSA6IG5vZGUubmFtZSk7XG5cbiAgZnVuY3Rpb24gdW5pcXVlKG5vZGVzOiBOb2RlW10pOiBOb2RlW10ge1xuICAgIHJldHVybiBbLi4ubmV3IE1hcChub2Rlcy5tYXAoKG5vZGUpID0+IFtub2RlLm5hbWUsIG5vZGVdKSkudmFsdWVzKCldO1xuICB9XG4gIGNvbnN0IHByZWRlZmluZWROb2RlcyA9IHVuaXF1ZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5wdXROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ncmFwaC53ZWlnaHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmluaXROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXSkuZmlsdGVyKGlzVXNlZCk7XG4gIGNvbnN0IGFsbE5vZGVzID0gdW5pcXVlKFtcbiAgICAgICAgICAgICAgICAgICAgIC4uLnByZWRlZmluZWROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMoZ3JhcGgubm9kZXMpLFxuICAgICAgICAgICAgICAgICAgIF0pLmZpbHRlcihpc1VzZWQpO1xuICBjb25zdCBuYW1lVG9Ob2RlID1cbiAgICAgIG5ldyBNYXA8c3RyaW5nLCBOb2RlPihhbGxOb2Rlcy5tYXAoKG5vZGUpID0+IFtub2RlLm5hbWUsIG5vZGVdKSk7XG5cbiAgY29uc3QgaW5Db3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgZm9yIChjb25zdCBub2RlIG9mIGFsbE5vZGVzKSB7XG4gICAgaW5Db3VudHNbbm9kZS5uYW1lXSA9IGluQ291bnRzW25vZGUubmFtZV0gfHwgMDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIC8vIFdoZW4gdGhlIGNoaWxkIGlzIHVudXNlZCwgc2V0IGluIGNvdW50cyB0byBpbmZpbml0eSBzbyB0aGF0IGl0IHdpbGxcbiAgICAgIC8vIG5ldmVyIGJlIGRlY3JlYXNlZCB0byAwIGFuZCBhZGRlZCB0byB0aGUgZXhlY3V0aW9uIGxpc3QuXG4gICAgICBpZiAoIWlzVXNlZChjaGlsZCkpIHtcbiAgICAgICAgaW5Db3VudHNbY2hpbGQubmFtZV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9XG4gICAgICBpbkNvdW50c1tjaGlsZC5uYW1lXSA9IChpbkNvdW50c1tjaGlsZC5uYW1lXSB8fCAwKSArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgZXhlY3V0aW9uIG9yZGVyIGZvciBhbGwgdXNlZCBub2RlcyByZWdhcmRsZXNzIHdoZXRoZXIgdGhleSBhcmVcbiAgLy8gcHJlZGVmaW5lZCBvciBub3QuXG4gIGNvbnN0IGZyb250aWVyID0gT2JqZWN0LmVudHJpZXMoaW5Db3VudHMpXG4gICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFssIGluQ291bnRdKSA9PiBpbkNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAubWFwKChbbmFtZV0pID0+IG5hbWUpO1xuICBjb25zdCBvcmRlcmVkTm9kZU5hbWVzID0gWy4uLmZyb250aWVyXTtcbiAgd2hpbGUgKGZyb250aWVyLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IGZyb250aWVyLnBvcCgpO1xuICAgIGNvbnN0IG5vZGUgPSBuYW1lVG9Ob2RlLmdldChub2RlTmFtZSkhO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbi5maWx0ZXIoaXNVc2VkKSkge1xuICAgICAgaWYgKC0taW5Db3VudHNbY2hpbGQubmFtZV0gPT09IDApIHtcbiAgICAgICAgb3JkZXJlZE5vZGVOYW1lcy5wdXNoKGNoaWxkLm5hbWUpO1xuICAgICAgICBmcm9udGllci5wdXNoKGNoaWxkLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9yZGVyZWROb2RlcyA9IG9yZGVyZWROb2RlTmFtZXMubWFwKChuYW1lKSA9PiBuYW1lVG9Ob2RlLmdldChuYW1lKSk7XG4gIGNvbnN0IGZpbHRlcmVkT3JkZXJlZE5vZGVzID1cbiAgICAgIGZpbHRlclByZWRlZmluZWRSZWFjaGFibGVOb2RlcyhvcmRlcmVkTm9kZXMsIHByZWRlZmluZWROb2Rlcyk7XG5cbiAgLy8gVE9ETzogVHVybiB2YWxpZGF0aW9uIG9uL29mZiB3aXRoIHRmIGVudiBmbGFnLlxuICB2YWxpZGF0ZU5vZGVzRXhlY3V0aW9uT3JkZXIoZmlsdGVyZWRPcmRlcmVkTm9kZXMsIHByZWRlZmluZWROb2Rlcyk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkT3JkZXJlZE5vZGVzO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gb2YgYGdldE5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyYC5cbiAqIFJldHVybnMgb3JkZXJlZCBub2RlcyByZWFjaGFibGUgYnkgYXQgbGVhc3Qgb25lIHByZWRlZmluZWQgbm9kZS5cbiAqIFRoaXMgY2FuIGhlbHAgdXMgZmlsdGVyIG91dCByZWR1bmRhbnQgbm9kZXMgZnJvbSB0aGUgcmV0dXJuZWQgbm9kZSBsaXN0LlxuICogRm9yIGV4YW1wbGU6XG4gKiBJZiB3ZSBoYXZlIGZvdXIgbm9kZXMgd2l0aCBkZXBlbmRlbmNpZXMgbGlrZSB0aGlzOlxuICogICBhIC0tPiBiIC0tPiBjIC0tPiBkXG4gKiB3aGVuIG5vZGUgYGNgIGlzIHByZWRlZmluZWQgKGUuZy4gZ2l2ZW4gYXMgYW4gaW5wdXQgdGVuc29yKSwgd2UgY2FuXG4gKiBza2lwIG5vZGUgYGFgIGFuZCBgYmAgc2luY2UgdGhlaXIgb3V0cHV0cyB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIG9yZGVyZWROb2RlcyBHcmFwaCBub2RlcyBpbiBleGVjdXRpb24gb3JkZXIuXG4gKiBAcGFyYW0gcHJlZGVmaW5lZE5vZGVzIEdyYXBoIGlucHV0cywgd2VpZ2h0cywgYW5kIGluaXQgbm9kZXMuIE5vZGVzIGluIHRoaXNcbiAqICAgICBsaXN0IG11c3QgaGF2ZSBkaXN0aW5jdCBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyUHJlZGVmaW5lZFJlYWNoYWJsZU5vZGVzKFxuICAgIG9yZGVyZWROb2RlczogTm9kZVtdLCBwcmVkZWZpbmVkTm9kZXM6IE5vZGVbXSkge1xuICBjb25zdCBuYW1lVG9Ob2RlID1cbiAgICAgIG5ldyBNYXA8c3RyaW5nLCBOb2RlPihvcmRlcmVkTm9kZXMubWFwKChub2RlKSA9PiBbbm9kZS5uYW1lLCBub2RlXSkpO1xuXG4gIC8vIFRPRE86IEZpbHRlciBvdXQgbW9yZSBub2RlcyB3aGVuID49MiBub2RlcyBhcmUgcHJlZGVmaW5lZCBpbiBhIHBhdGguXG4gIGNvbnN0IHN0YWNrID0gcHJlZGVmaW5lZE5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5uYW1lKTtcbiAgY29uc3QgcHJlZGVmaW5lZFJlYWNoYWJsZU5vZGVOYW1lcyA9IG5ldyBTZXQoc3RhY2spO1xuICAvLyBQZXJmb3JtIGEgREZTIHN0YXJ0aW5nIGZyb20gdGhlIHNldCBvZiBhbGwgcHJlZGVmaW5lZCBub2Rlc1xuICAvLyB0byBmaW5kIHRoZSBzZXQgb2YgYWxsIG5vZGVzIHJlYWNoYWJsZSBmcm9tIHRoZSBwcmVkZWZpbmVkIG5vZGVzLlxuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5vZGVOYW1lID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5hbWVUb05vZGUuZ2V0KG5vZGVOYW1lKSE7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5hbWVUb05vZGUuaGFzKGNoaWxkLm5hbWUpIHx8XG4gICAgICAgICAgcHJlZGVmaW5lZFJlYWNoYWJsZU5vZGVOYW1lcy5oYXMoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmVkZWZpbmVkUmVhY2hhYmxlTm9kZU5hbWVzLmFkZChjaGlsZC5uYW1lKTtcbiAgICAgIHN0YWNrLnB1c2goY2hpbGQubmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlsdGVyIG91dCB1bnJlYWNoYWJsZSBub2RlcyBhbmQgYnVpbGQgdGhlIG9yZGVyZWQgbm9kZSBsaXN0LlxuICBjb25zdCBmaWx0ZXJlZE9yZGVyZWROb2RlcyA9IG9yZGVyZWROb2Rlcy5maWx0ZXIoXG4gICAgICAobm9kZSkgPT4gcHJlZGVmaW5lZFJlYWNoYWJsZU5vZGVOYW1lcy5oYXMobm9kZS5uYW1lKSk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkT3JkZXJlZE5vZGVzO1xufVxuXG5jbGFzcyBOb2Rlc0V4ZWN1dGlvbk9yZGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKGBOb2Rlc0V4ZWN1dGlvbk9yZGVyRXJyb3I6ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gb2YgYGdldE5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyYC5cbiAqIFZhbGlkYXRlcyBwcm9wZXJ0eTogZ2l2ZW4gbm9kZXMgYGFgIGFuZCBgYmAsIE9yZGVyKGEpID4gT3JkZXIoYikgaWYgYGFgXG4gKiBpcyBhIGNoaWxkIG9mIGBiYC4gVGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gb3JkZXJlZE5vZGVzIEdyYXBoIG5vZGVzIGluIGV4ZWN1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSBwcmVkZWZpbmVkTm9kZXMgR3JhcGggaW5wdXRzLCB3ZWlnaHRzLCBhbmQgaW5pdCBub2Rlcy4gTm9kZXMgaW4gdGhpc1xuICogICAgIGxpc3QgbXVzdCBoYXZlIGRpc3RpbmN0IG5hbWVzLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5vZGVzRXhlY3V0aW9uT3JkZXIoXG4gICAgb3JkZXJlZE5vZGVzOiBOb2RlW10sIHByZWRlZmluZWROb2RlczogTm9kZVtdKSB7XG4gIGNvbnN0IG5vZGVOYW1lVG9PcmRlciA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KFxuICAgICAgb3JkZXJlZE5vZGVzLm1hcCgobm9kZSwgb3JkZXIpID0+IFtub2RlLm5hbWUsIG9yZGVyXSkpO1xuICBjb25zdCBwcmVkZWZpbmVkTm9kZU5hbWVzID0gbmV3IFNldChwcmVkZWZpbmVkTm9kZXMubWFwKChub2RlKSA9PiBub2RlLm5hbWUpKTtcbiAgY29uc3QgaXNQcmVkZWZpbmVkID0gKG5vZGU6IE5vZGV8c3RyaW5nKSA9PlxuICAgICAgcHJlZGVmaW5lZE5vZGVOYW1lcy5oYXModHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnID8gbm9kZSA6IG5vZGUubmFtZSk7XG4gIGNvbnN0IHdpbGxCZUV4ZWN1dGVkTm9kZU5hbWVzID1cbiAgICAgIG5ldyBTZXQob3JkZXJlZE5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5uYW1lKSk7XG4gIGNvbnN0IHdpbGxCZUV4ZWN1dGVkID0gKG5vZGU6IE5vZGV8c3RyaW5nKSA9PlxuICAgICAgd2lsbEJlRXhlY3V0ZWROb2RlTmFtZXMuaGFzKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyA/IG5vZGUgOiBub2RlLm5hbWUpO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBvcmRlcmVkTm9kZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4uZmlsdGVyKHdpbGxCZUV4ZWN1dGVkKSkge1xuICAgICAgaWYgKCFub2RlTmFtZVRvT3JkZXIuaGFzKGNoaWxkLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb2Rlc0V4ZWN1dGlvbk9yZGVyRXJyb3IoXG4gICAgICAgICAgICBgQ2hpbGQgJHtjaGlsZC5uYW1lfSBvZiBub2RlICR7bm9kZS5uYW1lfSBpcyB1bnJlYWNoYWJsZS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlTmFtZVRvT3JkZXIuZ2V0KG5vZGUubmFtZSkgPiBub2RlTmFtZVRvT3JkZXIuZ2V0KGNoaWxkLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb2Rlc0V4ZWN1dGlvbk9yZGVyRXJyb3IoYE5vZGUgJHtcbiAgICAgICAgICAgIG5vZGUubmFtZX0gaXMgc2NoZWR1bGVkIHRvIHJ1biBhZnRlciBpdHMgY2hpbGQgJHtjaGlsZC5uYW1lfS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1ByZWRlZmluZWQobm9kZSkpIHtcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygbm9kZS5pbnB1dHMpIHtcbiAgICAgICAgaWYgKCFub2RlTmFtZVRvT3JkZXIuaGFzKGlucHV0Lm5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE5vZGVzRXhlY3V0aW9uT3JkZXJFcnJvcihcbiAgICAgICAgICAgICAgYElucHV0ICR7aW5wdXQubmFtZX0gb2Ygbm9kZSAke25vZGUubmFtZX0gaXMgdW5yZWFjaGFibGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lVG9PcmRlci5nZXQoaW5wdXQubmFtZSkgPiBub2RlTmFtZVRvT3JkZXIuZ2V0KG5vZGUubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm9kZXNFeGVjdXRpb25PcmRlckVycm9yKGBOb2RlICR7XG4gICAgICAgICAgICAgIG5vZGUubmFtZX0gaXMgc2NoZWR1bGVkIHRvIHJ1biBiZWZvcmUgaXRzIGlucHV0ICR7aW5wdXQubmFtZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgZXhlY3V0aW9uIGluZm8sIHJldHVybiBhIG1hcCBmcm9tIG5vZGUgbmFtZSB0byB0aGUgZGlzcG9zYWJsZVxuICogbm9kZSBuYW1lIGxpc3QgYWZ0ZXIgaXRzIGV4ZWN1dGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIG1hcCBmcm9tIG5vZGUgbmFtZSB0byBkaXNwb3NhYmxlIG5vZGUgbmFtZXMgYWZ0ZXIgaXRzXG4gKiAgICAgZXhlY3V0aW9uLiBUaGF0IGlzLCBmb3IgYSBub2RlIGB4YCwgYG5vZGVMaXZlVW50aWxNYXBbeF1gIGluZGljYXRlc1xuICogICAgIGFsbCBub2RlcyB3aGljaCB0aGVpciBpbnRlcm1lZGlhdGUgdGVuc29ycyBzaG91bGQgYmUgZGlzcG9zZWQgYWZ0ZXIgYHhgXG4gKiAgICAgYmVpbmcgZXhlY3V0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlTGl2ZVVudGlsTWFwKG9yZGVyZWROb2RlczogTm9kZVtdKTpcbiAgICBNYXA8c3RyaW5nLCBzdHJpbmdbXT4ge1xuICBjb25zdCBub2RlTmFtZVRvT3JkZXIgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPihcbiAgICAgIG9yZGVyZWROb2Rlcy5tYXAoKG5vZGUsIG9yZGVyKSA9PiBbbm9kZS5uYW1lLCBvcmRlcl0pKTtcblxuICBjb25zdCBJTkZfTElGRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAvLyBNYWtlIGNvbnRyb2wgZmxvdyBub2RlcyAoYW5kIGNvbnNlcXVlbnRseSB0aGVpciBkaXJlY3QgcGFyZW50cylcbiAgLy8gbGl2ZSBmb3JldmVyIHNpbmNlIHRoZXkncmUgdHJpY2t5IHRvIHRyYWNrIGNvcnJlY3RseS5cbiAgY29uc3Qgc2VsZkxpZmVzcGFucyA9IG9yZGVyZWROb2Rlcy5tYXAoXG4gICAgICAobm9kZSwgbm9kZU9yZGVyKSA9PiBpc0NvbnRyb2xGbG93KG5vZGUpID8gSU5GX0xJRkUgOiBub2RlT3JkZXIpO1xuICBjb25zdCBnZXRTZWxmTGlmZVNwYW4gPSAobm9kZTogTm9kZSkgPT4ge1xuICAgIGNvbnN0IHNlbGZMaWZlID0gc2VsZkxpZmVzcGFuc1tub2RlTmFtZVRvT3JkZXIuZ2V0KG5vZGUubmFtZSkhXTtcbiAgICBpZiAoc2VsZkxpZmUgPT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm9kZVRvT3JkZXIgZG9lcyBub3QgY29udGFpbiB0aGUgbm9kZSwgaXQgaXMgdW51c2VkIG9yXG4gICAgICAvLyB1bnJlYWNoYWJsZSBpbiBncmFwaC5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGZMaWZlO1xuICB9O1xuXG4gIC8vIGBsaXZlVW50aWxbaV1gIHBvaW50cyB0byB0aGUgbGFzdCBub2RlIGluIHRoZSBgb3JkZXJlZE5vZGVzYCBhcnJheSB0aGF0XG4gIC8vIG1heSBkZXBlbmQgb24gdGVuc29ycyBmcm9tIG5vZGUgYGlgLiBJdCBpbmRpY2F0ZXMgdGhhdCBhbGwgdGhlXG4gIC8vIGludGVybWVkaWF0ZSB0ZW5zb3JzIGZyb20gYG9yZGVyZWROb2Rlc1tpXWAgc2hvdWxkIGJlIGRpc3Bvc2VkIGFmdGVyXG4gIC8vIGBvcmRlcmVkTm9kZXNbbGl2ZVVudGlsW2ldXWAgaXMgZXhlY3V0ZWQuXG4gIC8vIEEgbm9kZSBsaXZlcyBsb25nIGVub3VnaCB0byBwYXNzIG9uIGl0cyB0ZW5zb3JzIHRvIGl0cyBjaGlsZHJlbi5cbiAgLy8gSXQgbGl2ZXMgdW50aWwgYXQgbGVhc3QgYG1heChub2RlJ3MgcG9zaXRpb24sIGNoaWxkcmVuJ3MgcG9zaXRpb25zKWAuXG4gIGNvbnN0IGxpdmVVbnRpbE9yZGVycyA9IG9yZGVyZWROb2Rlcy5tYXAoKG5vZGUsIG5vZGVPcmRlcikgPT4ge1xuICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChnZXRTZWxmTGlmZVNwYW4pXG4gICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpLCBzZWxmTGlmZXNwYW5zW25vZGVPcmRlcl0pO1xuICB9KTtcblxuICAvLyBsaXZlVW50aWxNYXA6XG4gIC8vIC0gS2V5OiBOYW1lIG9mIGEgbm9kZSBgeGBcbiAgLy8gLSBWYWx1ZXM6IEFsbCBub2RlcyB3aG9zZSBpbnRlcm1lZGlhdGUgdGVuc29ycyBzaG91bGQgYmUgZGlzcG9zZWRcbiAgLy8gICAgICAgICAgIGFmdGVyIGB4YCBpcyBleGVjdXRlZC5cbiAgY29uc3QgbGl2ZVVudGlsTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZ1tdPigpO1xuICBmb3IgKGxldCBub2RlT3JkZXIgPSAwOyBub2RlT3JkZXIgPCBvcmRlcmVkTm9kZXMubGVuZ3RoOyArK25vZGVPcmRlcikge1xuICAgIGNvbnN0IGxpdmVVbnRpbE9yZGVyID0gbGl2ZVVudGlsT3JkZXJzW25vZGVPcmRlcl07XG4gICAgaWYgKGxpdmVVbnRpbE9yZGVyID09PSBJTkZfTElGRSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBvcmRlcmVkTm9kZXNbbm9kZU9yZGVyXTtcbiAgICBjb25zdCBsaXZlVW50aWxOb2RlID0gb3JkZXJlZE5vZGVzW2xpdmVVbnRpbE9yZGVyXTtcbiAgICBpZiAoIWxpdmVVbnRpbE1hcC5oYXMobGl2ZVVudGlsTm9kZS5uYW1lKSkge1xuICAgICAgbGl2ZVVudGlsTWFwLnNldChsaXZlVW50aWxOb2RlLm5hbWUsIFtdKTtcbiAgICB9XG4gICAgbGl2ZVVudGlsTWFwLmdldChsaXZlVW50aWxOb2RlLm5hbWUpIS5wdXNoKG5vZGUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIGxpdmVVbnRpbE1hcDtcbn1cblxuY29uc3QgQ09OVFJPTF9GTE9XX09QUyA9IG5ldyBTZXQoW1xuICAnU3dpdGNoJywgJ01lcmdlJywgJ0VudGVyJywgJ0V4aXQnLCAnTmV4dEl0ZXJhdGlvbicsICdTdGF0ZWxlc3NJZicsXG4gICdTdGF0ZWxlc3NXaGlsZScsICdpZicsICdXaGlsZSdcbl0pO1xuY29uc3QgRFlOQU1JQ19TSEFQRV9PUFMgPSBuZXcgU2V0KFtcbiAgJ05vbk1heFN1cHByZXNzaW9uVjInLCAnTm9uTWF4U3VwcHJlc3Npb25WMycsICdOb25NYXhTdXBwcmVzc2lvblY1JywgJ1doZXJlJ1xuXSk7XG5jb25zdCBIQVNIX1RBQkxFX09QUyA9IG5ldyBTZXQoW1xuICAnSGFzaFRhYmxlJywgJ0hhc2hUYWJsZVYyJywgJ0xvb2t1cFRhYmxlSW1wb3J0JywgJ0xvb2t1cFRhYmxlSW1wb3J0VjInLFxuICAnTG9va3VwVGFibGVGaW5kJywgJ0xvb2t1cFRhYmxlRmluZFYyJywgJ0xvb2t1cFRhYmxlU2l6ZScsICdMb29rdXBUYWJsZVNpemVWMidcbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb250cm9sRmxvdyhub2RlOiBOb2RlKSB7XG4gIHJldHVybiBDT05UUk9MX0ZMT1dfT1BTLmhhcyhub2RlLm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1NoYXBlKG5vZGU6IE5vZGUpIHtcbiAgcmV0dXJuIERZTkFNSUNfU0hBUEVfT1BTLmhhcyhub2RlLm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGFzaFRhYmxlKG5vZGU6IE5vZGUpIHtcbiAgcmV0dXJuIEhBU0hfVEFCTEVfT1BTLmhhcyhub2RlLm9wKTtcbn1cbiJdfQ==